// Code generated by http://github.com/gojuno/minimock (v3.4.0). DO NOT EDIT.

package server

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/AskaryanKarine/BMSTU-ds-1/internal/models"
	"github.com/gojuno/minimock/v3"
)

// PersonRepositoryMock implements personRepository
type PersonRepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCreatePerson          func(person models.Person) (p1 models.Person, err error)
	funcCreatePersonOrigin    string
	inspectFuncCreatePerson   func(person models.Person)
	afterCreatePersonCounter  uint64
	beforeCreatePersonCounter uint64
	CreatePersonMock          mPersonRepositoryMockCreatePerson

	funcDeletePersonByID          func(id int32) (err error)
	funcDeletePersonByIDOrigin    string
	inspectFuncDeletePersonByID   func(id int32)
	afterDeletePersonByIDCounter  uint64
	beforeDeletePersonByIDCounter uint64
	DeletePersonByIDMock          mPersonRepositoryMockDeletePersonByID

	funcGetAllPerson          func() (pa1 []models.Person, err error)
	funcGetAllPersonOrigin    string
	inspectFuncGetAllPerson   func()
	afterGetAllPersonCounter  uint64
	beforeGetAllPersonCounter uint64
	GetAllPersonMock          mPersonRepositoryMockGetAllPerson

	funcGetPersonByID          func(id int32) (p1 models.Person, err error)
	funcGetPersonByIDOrigin    string
	inspectFuncGetPersonByID   func(id int32)
	afterGetPersonByIDCounter  uint64
	beforeGetPersonByIDCounter uint64
	GetPersonByIDMock          mPersonRepositoryMockGetPersonByID

	funcUpdatePersonByID          func(id int32, person models.Person) (err error)
	funcUpdatePersonByIDOrigin    string
	inspectFuncUpdatePersonByID   func(id int32, person models.Person)
	afterUpdatePersonByIDCounter  uint64
	beforeUpdatePersonByIDCounter uint64
	UpdatePersonByIDMock          mPersonRepositoryMockUpdatePersonByID
}

// NewPersonRepositoryMock returns a mock for personRepository
func NewPersonRepositoryMock(t minimock.Tester) *PersonRepositoryMock {
	m := &PersonRepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreatePersonMock = mPersonRepositoryMockCreatePerson{mock: m}
	m.CreatePersonMock.callArgs = []*PersonRepositoryMockCreatePersonParams{}

	m.DeletePersonByIDMock = mPersonRepositoryMockDeletePersonByID{mock: m}
	m.DeletePersonByIDMock.callArgs = []*PersonRepositoryMockDeletePersonByIDParams{}

	m.GetAllPersonMock = mPersonRepositoryMockGetAllPerson{mock: m}

	m.GetPersonByIDMock = mPersonRepositoryMockGetPersonByID{mock: m}
	m.GetPersonByIDMock.callArgs = []*PersonRepositoryMockGetPersonByIDParams{}

	m.UpdatePersonByIDMock = mPersonRepositoryMockUpdatePersonByID{mock: m}
	m.UpdatePersonByIDMock.callArgs = []*PersonRepositoryMockUpdatePersonByIDParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mPersonRepositoryMockCreatePerson struct {
	optional           bool
	mock               *PersonRepositoryMock
	defaultExpectation *PersonRepositoryMockCreatePersonExpectation
	expectations       []*PersonRepositoryMockCreatePersonExpectation

	callArgs []*PersonRepositoryMockCreatePersonParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PersonRepositoryMockCreatePersonExpectation specifies expectation struct of the personRepository.CreatePerson
type PersonRepositoryMockCreatePersonExpectation struct {
	mock               *PersonRepositoryMock
	params             *PersonRepositoryMockCreatePersonParams
	paramPtrs          *PersonRepositoryMockCreatePersonParamPtrs
	expectationOrigins PersonRepositoryMockCreatePersonExpectationOrigins
	results            *PersonRepositoryMockCreatePersonResults
	returnOrigin       string
	Counter            uint64
}

// PersonRepositoryMockCreatePersonParams contains parameters of the personRepository.CreatePerson
type PersonRepositoryMockCreatePersonParams struct {
	person models.Person
}

// PersonRepositoryMockCreatePersonParamPtrs contains pointers to parameters of the personRepository.CreatePerson
type PersonRepositoryMockCreatePersonParamPtrs struct {
	person *models.Person
}

// PersonRepositoryMockCreatePersonResults contains results of the personRepository.CreatePerson
type PersonRepositoryMockCreatePersonResults struct {
	p1  models.Person
	err error
}

// PersonRepositoryMockCreatePersonOrigins contains origins of expectations of the personRepository.CreatePerson
type PersonRepositoryMockCreatePersonExpectationOrigins struct {
	origin       string
	originPerson string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreatePerson *mPersonRepositoryMockCreatePerson) Optional() *mPersonRepositoryMockCreatePerson {
	mmCreatePerson.optional = true
	return mmCreatePerson
}

// Expect sets up expected params for personRepository.CreatePerson
func (mmCreatePerson *mPersonRepositoryMockCreatePerson) Expect(person models.Person) *mPersonRepositoryMockCreatePerson {
	if mmCreatePerson.mock.funcCreatePerson != nil {
		mmCreatePerson.mock.t.Fatalf("PersonRepositoryMock.CreatePerson mock is already set by Set")
	}

	if mmCreatePerson.defaultExpectation == nil {
		mmCreatePerson.defaultExpectation = &PersonRepositoryMockCreatePersonExpectation{}
	}

	if mmCreatePerson.defaultExpectation.paramPtrs != nil {
		mmCreatePerson.mock.t.Fatalf("PersonRepositoryMock.CreatePerson mock is already set by ExpectParams functions")
	}

	mmCreatePerson.defaultExpectation.params = &PersonRepositoryMockCreatePersonParams{person}
	mmCreatePerson.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreatePerson.expectations {
		if minimock.Equal(e.params, mmCreatePerson.defaultExpectation.params) {
			mmCreatePerson.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreatePerson.defaultExpectation.params)
		}
	}

	return mmCreatePerson
}

// ExpectPersonParam1 sets up expected param person for personRepository.CreatePerson
func (mmCreatePerson *mPersonRepositoryMockCreatePerson) ExpectPersonParam1(person models.Person) *mPersonRepositoryMockCreatePerson {
	if mmCreatePerson.mock.funcCreatePerson != nil {
		mmCreatePerson.mock.t.Fatalf("PersonRepositoryMock.CreatePerson mock is already set by Set")
	}

	if mmCreatePerson.defaultExpectation == nil {
		mmCreatePerson.defaultExpectation = &PersonRepositoryMockCreatePersonExpectation{}
	}

	if mmCreatePerson.defaultExpectation.params != nil {
		mmCreatePerson.mock.t.Fatalf("PersonRepositoryMock.CreatePerson mock is already set by Expect")
	}

	if mmCreatePerson.defaultExpectation.paramPtrs == nil {
		mmCreatePerson.defaultExpectation.paramPtrs = &PersonRepositoryMockCreatePersonParamPtrs{}
	}
	mmCreatePerson.defaultExpectation.paramPtrs.person = &person
	mmCreatePerson.defaultExpectation.expectationOrigins.originPerson = minimock.CallerInfo(1)

	return mmCreatePerson
}

// Inspect accepts an inspector function that has same arguments as the personRepository.CreatePerson
func (mmCreatePerson *mPersonRepositoryMockCreatePerson) Inspect(f func(person models.Person)) *mPersonRepositoryMockCreatePerson {
	if mmCreatePerson.mock.inspectFuncCreatePerson != nil {
		mmCreatePerson.mock.t.Fatalf("Inspect function is already set for PersonRepositoryMock.CreatePerson")
	}

	mmCreatePerson.mock.inspectFuncCreatePerson = f

	return mmCreatePerson
}

// Return sets up results that will be returned by personRepository.CreatePerson
func (mmCreatePerson *mPersonRepositoryMockCreatePerson) Return(p1 models.Person, err error) *PersonRepositoryMock {
	if mmCreatePerson.mock.funcCreatePerson != nil {
		mmCreatePerson.mock.t.Fatalf("PersonRepositoryMock.CreatePerson mock is already set by Set")
	}

	if mmCreatePerson.defaultExpectation == nil {
		mmCreatePerson.defaultExpectation = &PersonRepositoryMockCreatePersonExpectation{mock: mmCreatePerson.mock}
	}
	mmCreatePerson.defaultExpectation.results = &PersonRepositoryMockCreatePersonResults{p1, err}
	mmCreatePerson.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreatePerson.mock
}

// Set uses given function f to mock the personRepository.CreatePerson method
func (mmCreatePerson *mPersonRepositoryMockCreatePerson) Set(f func(person models.Person) (p1 models.Person, err error)) *PersonRepositoryMock {
	if mmCreatePerson.defaultExpectation != nil {
		mmCreatePerson.mock.t.Fatalf("Default expectation is already set for the personRepository.CreatePerson method")
	}

	if len(mmCreatePerson.expectations) > 0 {
		mmCreatePerson.mock.t.Fatalf("Some expectations are already set for the personRepository.CreatePerson method")
	}

	mmCreatePerson.mock.funcCreatePerson = f
	mmCreatePerson.mock.funcCreatePersonOrigin = minimock.CallerInfo(1)
	return mmCreatePerson.mock
}

// When sets expectation for the personRepository.CreatePerson which will trigger the result defined by the following
// Then helper
func (mmCreatePerson *mPersonRepositoryMockCreatePerson) When(person models.Person) *PersonRepositoryMockCreatePersonExpectation {
	if mmCreatePerson.mock.funcCreatePerson != nil {
		mmCreatePerson.mock.t.Fatalf("PersonRepositoryMock.CreatePerson mock is already set by Set")
	}

	expectation := &PersonRepositoryMockCreatePersonExpectation{
		mock:               mmCreatePerson.mock,
		params:             &PersonRepositoryMockCreatePersonParams{person},
		expectationOrigins: PersonRepositoryMockCreatePersonExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreatePerson.expectations = append(mmCreatePerson.expectations, expectation)
	return expectation
}

// Then sets up personRepository.CreatePerson return parameters for the expectation previously defined by the When method
func (e *PersonRepositoryMockCreatePersonExpectation) Then(p1 models.Person, err error) *PersonRepositoryMock {
	e.results = &PersonRepositoryMockCreatePersonResults{p1, err}
	return e.mock
}

// Times sets number of times personRepository.CreatePerson should be invoked
func (mmCreatePerson *mPersonRepositoryMockCreatePerson) Times(n uint64) *mPersonRepositoryMockCreatePerson {
	if n == 0 {
		mmCreatePerson.mock.t.Fatalf("Times of PersonRepositoryMock.CreatePerson mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreatePerson.expectedInvocations, n)
	mmCreatePerson.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreatePerson
}

func (mmCreatePerson *mPersonRepositoryMockCreatePerson) invocationsDone() bool {
	if len(mmCreatePerson.expectations) == 0 && mmCreatePerson.defaultExpectation == nil && mmCreatePerson.mock.funcCreatePerson == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreatePerson.mock.afterCreatePersonCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreatePerson.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreatePerson implements personRepository
func (mmCreatePerson *PersonRepositoryMock) CreatePerson(person models.Person) (p1 models.Person, err error) {
	mm_atomic.AddUint64(&mmCreatePerson.beforeCreatePersonCounter, 1)
	defer mm_atomic.AddUint64(&mmCreatePerson.afterCreatePersonCounter, 1)

	mmCreatePerson.t.Helper()

	if mmCreatePerson.inspectFuncCreatePerson != nil {
		mmCreatePerson.inspectFuncCreatePerson(person)
	}

	mm_params := PersonRepositoryMockCreatePersonParams{person}

	// Record call args
	mmCreatePerson.CreatePersonMock.mutex.Lock()
	mmCreatePerson.CreatePersonMock.callArgs = append(mmCreatePerson.CreatePersonMock.callArgs, &mm_params)
	mmCreatePerson.CreatePersonMock.mutex.Unlock()

	for _, e := range mmCreatePerson.CreatePersonMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.p1, e.results.err
		}
	}

	if mmCreatePerson.CreatePersonMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreatePerson.CreatePersonMock.defaultExpectation.Counter, 1)
		mm_want := mmCreatePerson.CreatePersonMock.defaultExpectation.params
		mm_want_ptrs := mmCreatePerson.CreatePersonMock.defaultExpectation.paramPtrs

		mm_got := PersonRepositoryMockCreatePersonParams{person}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.person != nil && !minimock.Equal(*mm_want_ptrs.person, mm_got.person) {
				mmCreatePerson.t.Errorf("PersonRepositoryMock.CreatePerson got unexpected parameter person, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreatePerson.CreatePersonMock.defaultExpectation.expectationOrigins.originPerson, *mm_want_ptrs.person, mm_got.person, minimock.Diff(*mm_want_ptrs.person, mm_got.person))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreatePerson.t.Errorf("PersonRepositoryMock.CreatePerson got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreatePerson.CreatePersonMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreatePerson.CreatePersonMock.defaultExpectation.results
		if mm_results == nil {
			mmCreatePerson.t.Fatal("No results are set for the PersonRepositoryMock.CreatePerson")
		}
		return (*mm_results).p1, (*mm_results).err
	}
	if mmCreatePerson.funcCreatePerson != nil {
		return mmCreatePerson.funcCreatePerson(person)
	}
	mmCreatePerson.t.Fatalf("Unexpected call to PersonRepositoryMock.CreatePerson. %v", person)
	return
}

// CreatePersonAfterCounter returns a count of finished PersonRepositoryMock.CreatePerson invocations
func (mmCreatePerson *PersonRepositoryMock) CreatePersonAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreatePerson.afterCreatePersonCounter)
}

// CreatePersonBeforeCounter returns a count of PersonRepositoryMock.CreatePerson invocations
func (mmCreatePerson *PersonRepositoryMock) CreatePersonBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreatePerson.beforeCreatePersonCounter)
}

// Calls returns a list of arguments used in each call to PersonRepositoryMock.CreatePerson.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreatePerson *mPersonRepositoryMockCreatePerson) Calls() []*PersonRepositoryMockCreatePersonParams {
	mmCreatePerson.mutex.RLock()

	argCopy := make([]*PersonRepositoryMockCreatePersonParams, len(mmCreatePerson.callArgs))
	copy(argCopy, mmCreatePerson.callArgs)

	mmCreatePerson.mutex.RUnlock()

	return argCopy
}

// MinimockCreatePersonDone returns true if the count of the CreatePerson invocations corresponds
// the number of defined expectations
func (m *PersonRepositoryMock) MinimockCreatePersonDone() bool {
	if m.CreatePersonMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreatePersonMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreatePersonMock.invocationsDone()
}

// MinimockCreatePersonInspect logs each unmet expectation
func (m *PersonRepositoryMock) MinimockCreatePersonInspect() {
	for _, e := range m.CreatePersonMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PersonRepositoryMock.CreatePerson at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreatePersonCounter := mm_atomic.LoadUint64(&m.afterCreatePersonCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreatePersonMock.defaultExpectation != nil && afterCreatePersonCounter < 1 {
		if m.CreatePersonMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PersonRepositoryMock.CreatePerson at\n%s", m.CreatePersonMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PersonRepositoryMock.CreatePerson at\n%s with params: %#v", m.CreatePersonMock.defaultExpectation.expectationOrigins.origin, *m.CreatePersonMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreatePerson != nil && afterCreatePersonCounter < 1 {
		m.t.Errorf("Expected call to PersonRepositoryMock.CreatePerson at\n%s", m.funcCreatePersonOrigin)
	}

	if !m.CreatePersonMock.invocationsDone() && afterCreatePersonCounter > 0 {
		m.t.Errorf("Expected %d calls to PersonRepositoryMock.CreatePerson at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreatePersonMock.expectedInvocations), m.CreatePersonMock.expectedInvocationsOrigin, afterCreatePersonCounter)
	}
}

type mPersonRepositoryMockDeletePersonByID struct {
	optional           bool
	mock               *PersonRepositoryMock
	defaultExpectation *PersonRepositoryMockDeletePersonByIDExpectation
	expectations       []*PersonRepositoryMockDeletePersonByIDExpectation

	callArgs []*PersonRepositoryMockDeletePersonByIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PersonRepositoryMockDeletePersonByIDExpectation specifies expectation struct of the personRepository.DeletePersonByID
type PersonRepositoryMockDeletePersonByIDExpectation struct {
	mock               *PersonRepositoryMock
	params             *PersonRepositoryMockDeletePersonByIDParams
	paramPtrs          *PersonRepositoryMockDeletePersonByIDParamPtrs
	expectationOrigins PersonRepositoryMockDeletePersonByIDExpectationOrigins
	results            *PersonRepositoryMockDeletePersonByIDResults
	returnOrigin       string
	Counter            uint64
}

// PersonRepositoryMockDeletePersonByIDParams contains parameters of the personRepository.DeletePersonByID
type PersonRepositoryMockDeletePersonByIDParams struct {
	id int32
}

// PersonRepositoryMockDeletePersonByIDParamPtrs contains pointers to parameters of the personRepository.DeletePersonByID
type PersonRepositoryMockDeletePersonByIDParamPtrs struct {
	id *int32
}

// PersonRepositoryMockDeletePersonByIDResults contains results of the personRepository.DeletePersonByID
type PersonRepositoryMockDeletePersonByIDResults struct {
	err error
}

// PersonRepositoryMockDeletePersonByIDOrigins contains origins of expectations of the personRepository.DeletePersonByID
type PersonRepositoryMockDeletePersonByIDExpectationOrigins struct {
	origin   string
	originId string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeletePersonByID *mPersonRepositoryMockDeletePersonByID) Optional() *mPersonRepositoryMockDeletePersonByID {
	mmDeletePersonByID.optional = true
	return mmDeletePersonByID
}

// Expect sets up expected params for personRepository.DeletePersonByID
func (mmDeletePersonByID *mPersonRepositoryMockDeletePersonByID) Expect(id int32) *mPersonRepositoryMockDeletePersonByID {
	if mmDeletePersonByID.mock.funcDeletePersonByID != nil {
		mmDeletePersonByID.mock.t.Fatalf("PersonRepositoryMock.DeletePersonByID mock is already set by Set")
	}

	if mmDeletePersonByID.defaultExpectation == nil {
		mmDeletePersonByID.defaultExpectation = &PersonRepositoryMockDeletePersonByIDExpectation{}
	}

	if mmDeletePersonByID.defaultExpectation.paramPtrs != nil {
		mmDeletePersonByID.mock.t.Fatalf("PersonRepositoryMock.DeletePersonByID mock is already set by ExpectParams functions")
	}

	mmDeletePersonByID.defaultExpectation.params = &PersonRepositoryMockDeletePersonByIDParams{id}
	mmDeletePersonByID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeletePersonByID.expectations {
		if minimock.Equal(e.params, mmDeletePersonByID.defaultExpectation.params) {
			mmDeletePersonByID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeletePersonByID.defaultExpectation.params)
		}
	}

	return mmDeletePersonByID
}

// ExpectIdParam1 sets up expected param id for personRepository.DeletePersonByID
func (mmDeletePersonByID *mPersonRepositoryMockDeletePersonByID) ExpectIdParam1(id int32) *mPersonRepositoryMockDeletePersonByID {
	if mmDeletePersonByID.mock.funcDeletePersonByID != nil {
		mmDeletePersonByID.mock.t.Fatalf("PersonRepositoryMock.DeletePersonByID mock is already set by Set")
	}

	if mmDeletePersonByID.defaultExpectation == nil {
		mmDeletePersonByID.defaultExpectation = &PersonRepositoryMockDeletePersonByIDExpectation{}
	}

	if mmDeletePersonByID.defaultExpectation.params != nil {
		mmDeletePersonByID.mock.t.Fatalf("PersonRepositoryMock.DeletePersonByID mock is already set by Expect")
	}

	if mmDeletePersonByID.defaultExpectation.paramPtrs == nil {
		mmDeletePersonByID.defaultExpectation.paramPtrs = &PersonRepositoryMockDeletePersonByIDParamPtrs{}
	}
	mmDeletePersonByID.defaultExpectation.paramPtrs.id = &id
	mmDeletePersonByID.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmDeletePersonByID
}

// Inspect accepts an inspector function that has same arguments as the personRepository.DeletePersonByID
func (mmDeletePersonByID *mPersonRepositoryMockDeletePersonByID) Inspect(f func(id int32)) *mPersonRepositoryMockDeletePersonByID {
	if mmDeletePersonByID.mock.inspectFuncDeletePersonByID != nil {
		mmDeletePersonByID.mock.t.Fatalf("Inspect function is already set for PersonRepositoryMock.DeletePersonByID")
	}

	mmDeletePersonByID.mock.inspectFuncDeletePersonByID = f

	return mmDeletePersonByID
}

// Return sets up results that will be returned by personRepository.DeletePersonByID
func (mmDeletePersonByID *mPersonRepositoryMockDeletePersonByID) Return(err error) *PersonRepositoryMock {
	if mmDeletePersonByID.mock.funcDeletePersonByID != nil {
		mmDeletePersonByID.mock.t.Fatalf("PersonRepositoryMock.DeletePersonByID mock is already set by Set")
	}

	if mmDeletePersonByID.defaultExpectation == nil {
		mmDeletePersonByID.defaultExpectation = &PersonRepositoryMockDeletePersonByIDExpectation{mock: mmDeletePersonByID.mock}
	}
	mmDeletePersonByID.defaultExpectation.results = &PersonRepositoryMockDeletePersonByIDResults{err}
	mmDeletePersonByID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeletePersonByID.mock
}

// Set uses given function f to mock the personRepository.DeletePersonByID method
func (mmDeletePersonByID *mPersonRepositoryMockDeletePersonByID) Set(f func(id int32) (err error)) *PersonRepositoryMock {
	if mmDeletePersonByID.defaultExpectation != nil {
		mmDeletePersonByID.mock.t.Fatalf("Default expectation is already set for the personRepository.DeletePersonByID method")
	}

	if len(mmDeletePersonByID.expectations) > 0 {
		mmDeletePersonByID.mock.t.Fatalf("Some expectations are already set for the personRepository.DeletePersonByID method")
	}

	mmDeletePersonByID.mock.funcDeletePersonByID = f
	mmDeletePersonByID.mock.funcDeletePersonByIDOrigin = minimock.CallerInfo(1)
	return mmDeletePersonByID.mock
}

// When sets expectation for the personRepository.DeletePersonByID which will trigger the result defined by the following
// Then helper
func (mmDeletePersonByID *mPersonRepositoryMockDeletePersonByID) When(id int32) *PersonRepositoryMockDeletePersonByIDExpectation {
	if mmDeletePersonByID.mock.funcDeletePersonByID != nil {
		mmDeletePersonByID.mock.t.Fatalf("PersonRepositoryMock.DeletePersonByID mock is already set by Set")
	}

	expectation := &PersonRepositoryMockDeletePersonByIDExpectation{
		mock:               mmDeletePersonByID.mock,
		params:             &PersonRepositoryMockDeletePersonByIDParams{id},
		expectationOrigins: PersonRepositoryMockDeletePersonByIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeletePersonByID.expectations = append(mmDeletePersonByID.expectations, expectation)
	return expectation
}

// Then sets up personRepository.DeletePersonByID return parameters for the expectation previously defined by the When method
func (e *PersonRepositoryMockDeletePersonByIDExpectation) Then(err error) *PersonRepositoryMock {
	e.results = &PersonRepositoryMockDeletePersonByIDResults{err}
	return e.mock
}

// Times sets number of times personRepository.DeletePersonByID should be invoked
func (mmDeletePersonByID *mPersonRepositoryMockDeletePersonByID) Times(n uint64) *mPersonRepositoryMockDeletePersonByID {
	if n == 0 {
		mmDeletePersonByID.mock.t.Fatalf("Times of PersonRepositoryMock.DeletePersonByID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeletePersonByID.expectedInvocations, n)
	mmDeletePersonByID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeletePersonByID
}

func (mmDeletePersonByID *mPersonRepositoryMockDeletePersonByID) invocationsDone() bool {
	if len(mmDeletePersonByID.expectations) == 0 && mmDeletePersonByID.defaultExpectation == nil && mmDeletePersonByID.mock.funcDeletePersonByID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeletePersonByID.mock.afterDeletePersonByIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeletePersonByID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeletePersonByID implements personRepository
func (mmDeletePersonByID *PersonRepositoryMock) DeletePersonByID(id int32) (err error) {
	mm_atomic.AddUint64(&mmDeletePersonByID.beforeDeletePersonByIDCounter, 1)
	defer mm_atomic.AddUint64(&mmDeletePersonByID.afterDeletePersonByIDCounter, 1)

	mmDeletePersonByID.t.Helper()

	if mmDeletePersonByID.inspectFuncDeletePersonByID != nil {
		mmDeletePersonByID.inspectFuncDeletePersonByID(id)
	}

	mm_params := PersonRepositoryMockDeletePersonByIDParams{id}

	// Record call args
	mmDeletePersonByID.DeletePersonByIDMock.mutex.Lock()
	mmDeletePersonByID.DeletePersonByIDMock.callArgs = append(mmDeletePersonByID.DeletePersonByIDMock.callArgs, &mm_params)
	mmDeletePersonByID.DeletePersonByIDMock.mutex.Unlock()

	for _, e := range mmDeletePersonByID.DeletePersonByIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeletePersonByID.DeletePersonByIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeletePersonByID.DeletePersonByIDMock.defaultExpectation.Counter, 1)
		mm_want := mmDeletePersonByID.DeletePersonByIDMock.defaultExpectation.params
		mm_want_ptrs := mmDeletePersonByID.DeletePersonByIDMock.defaultExpectation.paramPtrs

		mm_got := PersonRepositoryMockDeletePersonByIDParams{id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmDeletePersonByID.t.Errorf("PersonRepositoryMock.DeletePersonByID got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeletePersonByID.DeletePersonByIDMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeletePersonByID.t.Errorf("PersonRepositoryMock.DeletePersonByID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeletePersonByID.DeletePersonByIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeletePersonByID.DeletePersonByIDMock.defaultExpectation.results
		if mm_results == nil {
			mmDeletePersonByID.t.Fatal("No results are set for the PersonRepositoryMock.DeletePersonByID")
		}
		return (*mm_results).err
	}
	if mmDeletePersonByID.funcDeletePersonByID != nil {
		return mmDeletePersonByID.funcDeletePersonByID(id)
	}
	mmDeletePersonByID.t.Fatalf("Unexpected call to PersonRepositoryMock.DeletePersonByID. %v", id)
	return
}

// DeletePersonByIDAfterCounter returns a count of finished PersonRepositoryMock.DeletePersonByID invocations
func (mmDeletePersonByID *PersonRepositoryMock) DeletePersonByIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeletePersonByID.afterDeletePersonByIDCounter)
}

// DeletePersonByIDBeforeCounter returns a count of PersonRepositoryMock.DeletePersonByID invocations
func (mmDeletePersonByID *PersonRepositoryMock) DeletePersonByIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeletePersonByID.beforeDeletePersonByIDCounter)
}

// Calls returns a list of arguments used in each call to PersonRepositoryMock.DeletePersonByID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeletePersonByID *mPersonRepositoryMockDeletePersonByID) Calls() []*PersonRepositoryMockDeletePersonByIDParams {
	mmDeletePersonByID.mutex.RLock()

	argCopy := make([]*PersonRepositoryMockDeletePersonByIDParams, len(mmDeletePersonByID.callArgs))
	copy(argCopy, mmDeletePersonByID.callArgs)

	mmDeletePersonByID.mutex.RUnlock()

	return argCopy
}

// MinimockDeletePersonByIDDone returns true if the count of the DeletePersonByID invocations corresponds
// the number of defined expectations
func (m *PersonRepositoryMock) MinimockDeletePersonByIDDone() bool {
	if m.DeletePersonByIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeletePersonByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeletePersonByIDMock.invocationsDone()
}

// MinimockDeletePersonByIDInspect logs each unmet expectation
func (m *PersonRepositoryMock) MinimockDeletePersonByIDInspect() {
	for _, e := range m.DeletePersonByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PersonRepositoryMock.DeletePersonByID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeletePersonByIDCounter := mm_atomic.LoadUint64(&m.afterDeletePersonByIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeletePersonByIDMock.defaultExpectation != nil && afterDeletePersonByIDCounter < 1 {
		if m.DeletePersonByIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PersonRepositoryMock.DeletePersonByID at\n%s", m.DeletePersonByIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PersonRepositoryMock.DeletePersonByID at\n%s with params: %#v", m.DeletePersonByIDMock.defaultExpectation.expectationOrigins.origin, *m.DeletePersonByIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeletePersonByID != nil && afterDeletePersonByIDCounter < 1 {
		m.t.Errorf("Expected call to PersonRepositoryMock.DeletePersonByID at\n%s", m.funcDeletePersonByIDOrigin)
	}

	if !m.DeletePersonByIDMock.invocationsDone() && afterDeletePersonByIDCounter > 0 {
		m.t.Errorf("Expected %d calls to PersonRepositoryMock.DeletePersonByID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeletePersonByIDMock.expectedInvocations), m.DeletePersonByIDMock.expectedInvocationsOrigin, afterDeletePersonByIDCounter)
	}
}

type mPersonRepositoryMockGetAllPerson struct {
	optional           bool
	mock               *PersonRepositoryMock
	defaultExpectation *PersonRepositoryMockGetAllPersonExpectation
	expectations       []*PersonRepositoryMockGetAllPersonExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PersonRepositoryMockGetAllPersonExpectation specifies expectation struct of the personRepository.GetAllPerson
type PersonRepositoryMockGetAllPersonExpectation struct {
	mock *PersonRepositoryMock

	results      *PersonRepositoryMockGetAllPersonResults
	returnOrigin string
	Counter      uint64
}

// PersonRepositoryMockGetAllPersonResults contains results of the personRepository.GetAllPerson
type PersonRepositoryMockGetAllPersonResults struct {
	pa1 []models.Person
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetAllPerson *mPersonRepositoryMockGetAllPerson) Optional() *mPersonRepositoryMockGetAllPerson {
	mmGetAllPerson.optional = true
	return mmGetAllPerson
}

// Expect sets up expected params for personRepository.GetAllPerson
func (mmGetAllPerson *mPersonRepositoryMockGetAllPerson) Expect() *mPersonRepositoryMockGetAllPerson {
	if mmGetAllPerson.mock.funcGetAllPerson != nil {
		mmGetAllPerson.mock.t.Fatalf("PersonRepositoryMock.GetAllPerson mock is already set by Set")
	}

	if mmGetAllPerson.defaultExpectation == nil {
		mmGetAllPerson.defaultExpectation = &PersonRepositoryMockGetAllPersonExpectation{}
	}

	return mmGetAllPerson
}

// Inspect accepts an inspector function that has same arguments as the personRepository.GetAllPerson
func (mmGetAllPerson *mPersonRepositoryMockGetAllPerson) Inspect(f func()) *mPersonRepositoryMockGetAllPerson {
	if mmGetAllPerson.mock.inspectFuncGetAllPerson != nil {
		mmGetAllPerson.mock.t.Fatalf("Inspect function is already set for PersonRepositoryMock.GetAllPerson")
	}

	mmGetAllPerson.mock.inspectFuncGetAllPerson = f

	return mmGetAllPerson
}

// Return sets up results that will be returned by personRepository.GetAllPerson
func (mmGetAllPerson *mPersonRepositoryMockGetAllPerson) Return(pa1 []models.Person, err error) *PersonRepositoryMock {
	if mmGetAllPerson.mock.funcGetAllPerson != nil {
		mmGetAllPerson.mock.t.Fatalf("PersonRepositoryMock.GetAllPerson mock is already set by Set")
	}

	if mmGetAllPerson.defaultExpectation == nil {
		mmGetAllPerson.defaultExpectation = &PersonRepositoryMockGetAllPersonExpectation{mock: mmGetAllPerson.mock}
	}
	mmGetAllPerson.defaultExpectation.results = &PersonRepositoryMockGetAllPersonResults{pa1, err}
	mmGetAllPerson.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetAllPerson.mock
}

// Set uses given function f to mock the personRepository.GetAllPerson method
func (mmGetAllPerson *mPersonRepositoryMockGetAllPerson) Set(f func() (pa1 []models.Person, err error)) *PersonRepositoryMock {
	if mmGetAllPerson.defaultExpectation != nil {
		mmGetAllPerson.mock.t.Fatalf("Default expectation is already set for the personRepository.GetAllPerson method")
	}

	if len(mmGetAllPerson.expectations) > 0 {
		mmGetAllPerson.mock.t.Fatalf("Some expectations are already set for the personRepository.GetAllPerson method")
	}

	mmGetAllPerson.mock.funcGetAllPerson = f
	mmGetAllPerson.mock.funcGetAllPersonOrigin = minimock.CallerInfo(1)
	return mmGetAllPerson.mock
}

// Times sets number of times personRepository.GetAllPerson should be invoked
func (mmGetAllPerson *mPersonRepositoryMockGetAllPerson) Times(n uint64) *mPersonRepositoryMockGetAllPerson {
	if n == 0 {
		mmGetAllPerson.mock.t.Fatalf("Times of PersonRepositoryMock.GetAllPerson mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetAllPerson.expectedInvocations, n)
	mmGetAllPerson.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetAllPerson
}

func (mmGetAllPerson *mPersonRepositoryMockGetAllPerson) invocationsDone() bool {
	if len(mmGetAllPerson.expectations) == 0 && mmGetAllPerson.defaultExpectation == nil && mmGetAllPerson.mock.funcGetAllPerson == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetAllPerson.mock.afterGetAllPersonCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetAllPerson.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetAllPerson implements personRepository
func (mmGetAllPerson *PersonRepositoryMock) GetAllPerson() (pa1 []models.Person, err error) {
	mm_atomic.AddUint64(&mmGetAllPerson.beforeGetAllPersonCounter, 1)
	defer mm_atomic.AddUint64(&mmGetAllPerson.afterGetAllPersonCounter, 1)

	mmGetAllPerson.t.Helper()

	if mmGetAllPerson.inspectFuncGetAllPerson != nil {
		mmGetAllPerson.inspectFuncGetAllPerson()
	}

	if mmGetAllPerson.GetAllPersonMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetAllPerson.GetAllPersonMock.defaultExpectation.Counter, 1)

		mm_results := mmGetAllPerson.GetAllPersonMock.defaultExpectation.results
		if mm_results == nil {
			mmGetAllPerson.t.Fatal("No results are set for the PersonRepositoryMock.GetAllPerson")
		}
		return (*mm_results).pa1, (*mm_results).err
	}
	if mmGetAllPerson.funcGetAllPerson != nil {
		return mmGetAllPerson.funcGetAllPerson()
	}
	mmGetAllPerson.t.Fatalf("Unexpected call to PersonRepositoryMock.GetAllPerson.")
	return
}

// GetAllPersonAfterCounter returns a count of finished PersonRepositoryMock.GetAllPerson invocations
func (mmGetAllPerson *PersonRepositoryMock) GetAllPersonAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetAllPerson.afterGetAllPersonCounter)
}

// GetAllPersonBeforeCounter returns a count of PersonRepositoryMock.GetAllPerson invocations
func (mmGetAllPerson *PersonRepositoryMock) GetAllPersonBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetAllPerson.beforeGetAllPersonCounter)
}

// MinimockGetAllPersonDone returns true if the count of the GetAllPerson invocations corresponds
// the number of defined expectations
func (m *PersonRepositoryMock) MinimockGetAllPersonDone() bool {
	if m.GetAllPersonMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetAllPersonMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetAllPersonMock.invocationsDone()
}

// MinimockGetAllPersonInspect logs each unmet expectation
func (m *PersonRepositoryMock) MinimockGetAllPersonInspect() {
	for _, e := range m.GetAllPersonMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to PersonRepositoryMock.GetAllPerson")
		}
	}

	afterGetAllPersonCounter := mm_atomic.LoadUint64(&m.afterGetAllPersonCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetAllPersonMock.defaultExpectation != nil && afterGetAllPersonCounter < 1 {
		m.t.Errorf("Expected call to PersonRepositoryMock.GetAllPerson at\n%s", m.GetAllPersonMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetAllPerson != nil && afterGetAllPersonCounter < 1 {
		m.t.Errorf("Expected call to PersonRepositoryMock.GetAllPerson at\n%s", m.funcGetAllPersonOrigin)
	}

	if !m.GetAllPersonMock.invocationsDone() && afterGetAllPersonCounter > 0 {
		m.t.Errorf("Expected %d calls to PersonRepositoryMock.GetAllPerson at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetAllPersonMock.expectedInvocations), m.GetAllPersonMock.expectedInvocationsOrigin, afterGetAllPersonCounter)
	}
}

type mPersonRepositoryMockGetPersonByID struct {
	optional           bool
	mock               *PersonRepositoryMock
	defaultExpectation *PersonRepositoryMockGetPersonByIDExpectation
	expectations       []*PersonRepositoryMockGetPersonByIDExpectation

	callArgs []*PersonRepositoryMockGetPersonByIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PersonRepositoryMockGetPersonByIDExpectation specifies expectation struct of the personRepository.GetPersonByID
type PersonRepositoryMockGetPersonByIDExpectation struct {
	mock               *PersonRepositoryMock
	params             *PersonRepositoryMockGetPersonByIDParams
	paramPtrs          *PersonRepositoryMockGetPersonByIDParamPtrs
	expectationOrigins PersonRepositoryMockGetPersonByIDExpectationOrigins
	results            *PersonRepositoryMockGetPersonByIDResults
	returnOrigin       string
	Counter            uint64
}

// PersonRepositoryMockGetPersonByIDParams contains parameters of the personRepository.GetPersonByID
type PersonRepositoryMockGetPersonByIDParams struct {
	id int32
}

// PersonRepositoryMockGetPersonByIDParamPtrs contains pointers to parameters of the personRepository.GetPersonByID
type PersonRepositoryMockGetPersonByIDParamPtrs struct {
	id *int32
}

// PersonRepositoryMockGetPersonByIDResults contains results of the personRepository.GetPersonByID
type PersonRepositoryMockGetPersonByIDResults struct {
	p1  models.Person
	err error
}

// PersonRepositoryMockGetPersonByIDOrigins contains origins of expectations of the personRepository.GetPersonByID
type PersonRepositoryMockGetPersonByIDExpectationOrigins struct {
	origin   string
	originId string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetPersonByID *mPersonRepositoryMockGetPersonByID) Optional() *mPersonRepositoryMockGetPersonByID {
	mmGetPersonByID.optional = true
	return mmGetPersonByID
}

// Expect sets up expected params for personRepository.GetPersonByID
func (mmGetPersonByID *mPersonRepositoryMockGetPersonByID) Expect(id int32) *mPersonRepositoryMockGetPersonByID {
	if mmGetPersonByID.mock.funcGetPersonByID != nil {
		mmGetPersonByID.mock.t.Fatalf("PersonRepositoryMock.GetPersonByID mock is already set by Set")
	}

	if mmGetPersonByID.defaultExpectation == nil {
		mmGetPersonByID.defaultExpectation = &PersonRepositoryMockGetPersonByIDExpectation{}
	}

	if mmGetPersonByID.defaultExpectation.paramPtrs != nil {
		mmGetPersonByID.mock.t.Fatalf("PersonRepositoryMock.GetPersonByID mock is already set by ExpectParams functions")
	}

	mmGetPersonByID.defaultExpectation.params = &PersonRepositoryMockGetPersonByIDParams{id}
	mmGetPersonByID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetPersonByID.expectations {
		if minimock.Equal(e.params, mmGetPersonByID.defaultExpectation.params) {
			mmGetPersonByID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetPersonByID.defaultExpectation.params)
		}
	}

	return mmGetPersonByID
}

// ExpectIdParam1 sets up expected param id for personRepository.GetPersonByID
func (mmGetPersonByID *mPersonRepositoryMockGetPersonByID) ExpectIdParam1(id int32) *mPersonRepositoryMockGetPersonByID {
	if mmGetPersonByID.mock.funcGetPersonByID != nil {
		mmGetPersonByID.mock.t.Fatalf("PersonRepositoryMock.GetPersonByID mock is already set by Set")
	}

	if mmGetPersonByID.defaultExpectation == nil {
		mmGetPersonByID.defaultExpectation = &PersonRepositoryMockGetPersonByIDExpectation{}
	}

	if mmGetPersonByID.defaultExpectation.params != nil {
		mmGetPersonByID.mock.t.Fatalf("PersonRepositoryMock.GetPersonByID mock is already set by Expect")
	}

	if mmGetPersonByID.defaultExpectation.paramPtrs == nil {
		mmGetPersonByID.defaultExpectation.paramPtrs = &PersonRepositoryMockGetPersonByIDParamPtrs{}
	}
	mmGetPersonByID.defaultExpectation.paramPtrs.id = &id
	mmGetPersonByID.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmGetPersonByID
}

// Inspect accepts an inspector function that has same arguments as the personRepository.GetPersonByID
func (mmGetPersonByID *mPersonRepositoryMockGetPersonByID) Inspect(f func(id int32)) *mPersonRepositoryMockGetPersonByID {
	if mmGetPersonByID.mock.inspectFuncGetPersonByID != nil {
		mmGetPersonByID.mock.t.Fatalf("Inspect function is already set for PersonRepositoryMock.GetPersonByID")
	}

	mmGetPersonByID.mock.inspectFuncGetPersonByID = f

	return mmGetPersonByID
}

// Return sets up results that will be returned by personRepository.GetPersonByID
func (mmGetPersonByID *mPersonRepositoryMockGetPersonByID) Return(p1 models.Person, err error) *PersonRepositoryMock {
	if mmGetPersonByID.mock.funcGetPersonByID != nil {
		mmGetPersonByID.mock.t.Fatalf("PersonRepositoryMock.GetPersonByID mock is already set by Set")
	}

	if mmGetPersonByID.defaultExpectation == nil {
		mmGetPersonByID.defaultExpectation = &PersonRepositoryMockGetPersonByIDExpectation{mock: mmGetPersonByID.mock}
	}
	mmGetPersonByID.defaultExpectation.results = &PersonRepositoryMockGetPersonByIDResults{p1, err}
	mmGetPersonByID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetPersonByID.mock
}

// Set uses given function f to mock the personRepository.GetPersonByID method
func (mmGetPersonByID *mPersonRepositoryMockGetPersonByID) Set(f func(id int32) (p1 models.Person, err error)) *PersonRepositoryMock {
	if mmGetPersonByID.defaultExpectation != nil {
		mmGetPersonByID.mock.t.Fatalf("Default expectation is already set for the personRepository.GetPersonByID method")
	}

	if len(mmGetPersonByID.expectations) > 0 {
		mmGetPersonByID.mock.t.Fatalf("Some expectations are already set for the personRepository.GetPersonByID method")
	}

	mmGetPersonByID.mock.funcGetPersonByID = f
	mmGetPersonByID.mock.funcGetPersonByIDOrigin = minimock.CallerInfo(1)
	return mmGetPersonByID.mock
}

// When sets expectation for the personRepository.GetPersonByID which will trigger the result defined by the following
// Then helper
func (mmGetPersonByID *mPersonRepositoryMockGetPersonByID) When(id int32) *PersonRepositoryMockGetPersonByIDExpectation {
	if mmGetPersonByID.mock.funcGetPersonByID != nil {
		mmGetPersonByID.mock.t.Fatalf("PersonRepositoryMock.GetPersonByID mock is already set by Set")
	}

	expectation := &PersonRepositoryMockGetPersonByIDExpectation{
		mock:               mmGetPersonByID.mock,
		params:             &PersonRepositoryMockGetPersonByIDParams{id},
		expectationOrigins: PersonRepositoryMockGetPersonByIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetPersonByID.expectations = append(mmGetPersonByID.expectations, expectation)
	return expectation
}

// Then sets up personRepository.GetPersonByID return parameters for the expectation previously defined by the When method
func (e *PersonRepositoryMockGetPersonByIDExpectation) Then(p1 models.Person, err error) *PersonRepositoryMock {
	e.results = &PersonRepositoryMockGetPersonByIDResults{p1, err}
	return e.mock
}

// Times sets number of times personRepository.GetPersonByID should be invoked
func (mmGetPersonByID *mPersonRepositoryMockGetPersonByID) Times(n uint64) *mPersonRepositoryMockGetPersonByID {
	if n == 0 {
		mmGetPersonByID.mock.t.Fatalf("Times of PersonRepositoryMock.GetPersonByID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetPersonByID.expectedInvocations, n)
	mmGetPersonByID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetPersonByID
}

func (mmGetPersonByID *mPersonRepositoryMockGetPersonByID) invocationsDone() bool {
	if len(mmGetPersonByID.expectations) == 0 && mmGetPersonByID.defaultExpectation == nil && mmGetPersonByID.mock.funcGetPersonByID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetPersonByID.mock.afterGetPersonByIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetPersonByID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetPersonByID implements personRepository
func (mmGetPersonByID *PersonRepositoryMock) GetPersonByID(id int32) (p1 models.Person, err error) {
	mm_atomic.AddUint64(&mmGetPersonByID.beforeGetPersonByIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetPersonByID.afterGetPersonByIDCounter, 1)

	mmGetPersonByID.t.Helper()

	if mmGetPersonByID.inspectFuncGetPersonByID != nil {
		mmGetPersonByID.inspectFuncGetPersonByID(id)
	}

	mm_params := PersonRepositoryMockGetPersonByIDParams{id}

	// Record call args
	mmGetPersonByID.GetPersonByIDMock.mutex.Lock()
	mmGetPersonByID.GetPersonByIDMock.callArgs = append(mmGetPersonByID.GetPersonByIDMock.callArgs, &mm_params)
	mmGetPersonByID.GetPersonByIDMock.mutex.Unlock()

	for _, e := range mmGetPersonByID.GetPersonByIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.p1, e.results.err
		}
	}

	if mmGetPersonByID.GetPersonByIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetPersonByID.GetPersonByIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetPersonByID.GetPersonByIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetPersonByID.GetPersonByIDMock.defaultExpectation.paramPtrs

		mm_got := PersonRepositoryMockGetPersonByIDParams{id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmGetPersonByID.t.Errorf("PersonRepositoryMock.GetPersonByID got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetPersonByID.GetPersonByIDMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetPersonByID.t.Errorf("PersonRepositoryMock.GetPersonByID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetPersonByID.GetPersonByIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetPersonByID.GetPersonByIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetPersonByID.t.Fatal("No results are set for the PersonRepositoryMock.GetPersonByID")
		}
		return (*mm_results).p1, (*mm_results).err
	}
	if mmGetPersonByID.funcGetPersonByID != nil {
		return mmGetPersonByID.funcGetPersonByID(id)
	}
	mmGetPersonByID.t.Fatalf("Unexpected call to PersonRepositoryMock.GetPersonByID. %v", id)
	return
}

// GetPersonByIDAfterCounter returns a count of finished PersonRepositoryMock.GetPersonByID invocations
func (mmGetPersonByID *PersonRepositoryMock) GetPersonByIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPersonByID.afterGetPersonByIDCounter)
}

// GetPersonByIDBeforeCounter returns a count of PersonRepositoryMock.GetPersonByID invocations
func (mmGetPersonByID *PersonRepositoryMock) GetPersonByIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPersonByID.beforeGetPersonByIDCounter)
}

// Calls returns a list of arguments used in each call to PersonRepositoryMock.GetPersonByID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetPersonByID *mPersonRepositoryMockGetPersonByID) Calls() []*PersonRepositoryMockGetPersonByIDParams {
	mmGetPersonByID.mutex.RLock()

	argCopy := make([]*PersonRepositoryMockGetPersonByIDParams, len(mmGetPersonByID.callArgs))
	copy(argCopy, mmGetPersonByID.callArgs)

	mmGetPersonByID.mutex.RUnlock()

	return argCopy
}

// MinimockGetPersonByIDDone returns true if the count of the GetPersonByID invocations corresponds
// the number of defined expectations
func (m *PersonRepositoryMock) MinimockGetPersonByIDDone() bool {
	if m.GetPersonByIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetPersonByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetPersonByIDMock.invocationsDone()
}

// MinimockGetPersonByIDInspect logs each unmet expectation
func (m *PersonRepositoryMock) MinimockGetPersonByIDInspect() {
	for _, e := range m.GetPersonByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PersonRepositoryMock.GetPersonByID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetPersonByIDCounter := mm_atomic.LoadUint64(&m.afterGetPersonByIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetPersonByIDMock.defaultExpectation != nil && afterGetPersonByIDCounter < 1 {
		if m.GetPersonByIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PersonRepositoryMock.GetPersonByID at\n%s", m.GetPersonByIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PersonRepositoryMock.GetPersonByID at\n%s with params: %#v", m.GetPersonByIDMock.defaultExpectation.expectationOrigins.origin, *m.GetPersonByIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPersonByID != nil && afterGetPersonByIDCounter < 1 {
		m.t.Errorf("Expected call to PersonRepositoryMock.GetPersonByID at\n%s", m.funcGetPersonByIDOrigin)
	}

	if !m.GetPersonByIDMock.invocationsDone() && afterGetPersonByIDCounter > 0 {
		m.t.Errorf("Expected %d calls to PersonRepositoryMock.GetPersonByID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetPersonByIDMock.expectedInvocations), m.GetPersonByIDMock.expectedInvocationsOrigin, afterGetPersonByIDCounter)
	}
}

type mPersonRepositoryMockUpdatePersonByID struct {
	optional           bool
	mock               *PersonRepositoryMock
	defaultExpectation *PersonRepositoryMockUpdatePersonByIDExpectation
	expectations       []*PersonRepositoryMockUpdatePersonByIDExpectation

	callArgs []*PersonRepositoryMockUpdatePersonByIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PersonRepositoryMockUpdatePersonByIDExpectation specifies expectation struct of the personRepository.UpdatePersonByID
type PersonRepositoryMockUpdatePersonByIDExpectation struct {
	mock               *PersonRepositoryMock
	params             *PersonRepositoryMockUpdatePersonByIDParams
	paramPtrs          *PersonRepositoryMockUpdatePersonByIDParamPtrs
	expectationOrigins PersonRepositoryMockUpdatePersonByIDExpectationOrigins
	results            *PersonRepositoryMockUpdatePersonByIDResults
	returnOrigin       string
	Counter            uint64
}

// PersonRepositoryMockUpdatePersonByIDParams contains parameters of the personRepository.UpdatePersonByID
type PersonRepositoryMockUpdatePersonByIDParams struct {
	id     int32
	person models.Person
}

// PersonRepositoryMockUpdatePersonByIDParamPtrs contains pointers to parameters of the personRepository.UpdatePersonByID
type PersonRepositoryMockUpdatePersonByIDParamPtrs struct {
	id     *int32
	person *models.Person
}

// PersonRepositoryMockUpdatePersonByIDResults contains results of the personRepository.UpdatePersonByID
type PersonRepositoryMockUpdatePersonByIDResults struct {
	err error
}

// PersonRepositoryMockUpdatePersonByIDOrigins contains origins of expectations of the personRepository.UpdatePersonByID
type PersonRepositoryMockUpdatePersonByIDExpectationOrigins struct {
	origin       string
	originId     string
	originPerson string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdatePersonByID *mPersonRepositoryMockUpdatePersonByID) Optional() *mPersonRepositoryMockUpdatePersonByID {
	mmUpdatePersonByID.optional = true
	return mmUpdatePersonByID
}

// Expect sets up expected params for personRepository.UpdatePersonByID
func (mmUpdatePersonByID *mPersonRepositoryMockUpdatePersonByID) Expect(id int32, person models.Person) *mPersonRepositoryMockUpdatePersonByID {
	if mmUpdatePersonByID.mock.funcUpdatePersonByID != nil {
		mmUpdatePersonByID.mock.t.Fatalf("PersonRepositoryMock.UpdatePersonByID mock is already set by Set")
	}

	if mmUpdatePersonByID.defaultExpectation == nil {
		mmUpdatePersonByID.defaultExpectation = &PersonRepositoryMockUpdatePersonByIDExpectation{}
	}

	if mmUpdatePersonByID.defaultExpectation.paramPtrs != nil {
		mmUpdatePersonByID.mock.t.Fatalf("PersonRepositoryMock.UpdatePersonByID mock is already set by ExpectParams functions")
	}

	mmUpdatePersonByID.defaultExpectation.params = &PersonRepositoryMockUpdatePersonByIDParams{id, person}
	mmUpdatePersonByID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdatePersonByID.expectations {
		if minimock.Equal(e.params, mmUpdatePersonByID.defaultExpectation.params) {
			mmUpdatePersonByID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdatePersonByID.defaultExpectation.params)
		}
	}

	return mmUpdatePersonByID
}

// ExpectIdParam1 sets up expected param id for personRepository.UpdatePersonByID
func (mmUpdatePersonByID *mPersonRepositoryMockUpdatePersonByID) ExpectIdParam1(id int32) *mPersonRepositoryMockUpdatePersonByID {
	if mmUpdatePersonByID.mock.funcUpdatePersonByID != nil {
		mmUpdatePersonByID.mock.t.Fatalf("PersonRepositoryMock.UpdatePersonByID mock is already set by Set")
	}

	if mmUpdatePersonByID.defaultExpectation == nil {
		mmUpdatePersonByID.defaultExpectation = &PersonRepositoryMockUpdatePersonByIDExpectation{}
	}

	if mmUpdatePersonByID.defaultExpectation.params != nil {
		mmUpdatePersonByID.mock.t.Fatalf("PersonRepositoryMock.UpdatePersonByID mock is already set by Expect")
	}

	if mmUpdatePersonByID.defaultExpectation.paramPtrs == nil {
		mmUpdatePersonByID.defaultExpectation.paramPtrs = &PersonRepositoryMockUpdatePersonByIDParamPtrs{}
	}
	mmUpdatePersonByID.defaultExpectation.paramPtrs.id = &id
	mmUpdatePersonByID.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmUpdatePersonByID
}

// ExpectPersonParam2 sets up expected param person for personRepository.UpdatePersonByID
func (mmUpdatePersonByID *mPersonRepositoryMockUpdatePersonByID) ExpectPersonParam2(person models.Person) *mPersonRepositoryMockUpdatePersonByID {
	if mmUpdatePersonByID.mock.funcUpdatePersonByID != nil {
		mmUpdatePersonByID.mock.t.Fatalf("PersonRepositoryMock.UpdatePersonByID mock is already set by Set")
	}

	if mmUpdatePersonByID.defaultExpectation == nil {
		mmUpdatePersonByID.defaultExpectation = &PersonRepositoryMockUpdatePersonByIDExpectation{}
	}

	if mmUpdatePersonByID.defaultExpectation.params != nil {
		mmUpdatePersonByID.mock.t.Fatalf("PersonRepositoryMock.UpdatePersonByID mock is already set by Expect")
	}

	if mmUpdatePersonByID.defaultExpectation.paramPtrs == nil {
		mmUpdatePersonByID.defaultExpectation.paramPtrs = &PersonRepositoryMockUpdatePersonByIDParamPtrs{}
	}
	mmUpdatePersonByID.defaultExpectation.paramPtrs.person = &person
	mmUpdatePersonByID.defaultExpectation.expectationOrigins.originPerson = minimock.CallerInfo(1)

	return mmUpdatePersonByID
}

// Inspect accepts an inspector function that has same arguments as the personRepository.UpdatePersonByID
func (mmUpdatePersonByID *mPersonRepositoryMockUpdatePersonByID) Inspect(f func(id int32, person models.Person)) *mPersonRepositoryMockUpdatePersonByID {
	if mmUpdatePersonByID.mock.inspectFuncUpdatePersonByID != nil {
		mmUpdatePersonByID.mock.t.Fatalf("Inspect function is already set for PersonRepositoryMock.UpdatePersonByID")
	}

	mmUpdatePersonByID.mock.inspectFuncUpdatePersonByID = f

	return mmUpdatePersonByID
}

// Return sets up results that will be returned by personRepository.UpdatePersonByID
func (mmUpdatePersonByID *mPersonRepositoryMockUpdatePersonByID) Return(err error) *PersonRepositoryMock {
	if mmUpdatePersonByID.mock.funcUpdatePersonByID != nil {
		mmUpdatePersonByID.mock.t.Fatalf("PersonRepositoryMock.UpdatePersonByID mock is already set by Set")
	}

	if mmUpdatePersonByID.defaultExpectation == nil {
		mmUpdatePersonByID.defaultExpectation = &PersonRepositoryMockUpdatePersonByIDExpectation{mock: mmUpdatePersonByID.mock}
	}
	mmUpdatePersonByID.defaultExpectation.results = &PersonRepositoryMockUpdatePersonByIDResults{err}
	mmUpdatePersonByID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdatePersonByID.mock
}

// Set uses given function f to mock the personRepository.UpdatePersonByID method
func (mmUpdatePersonByID *mPersonRepositoryMockUpdatePersonByID) Set(f func(id int32, person models.Person) (err error)) *PersonRepositoryMock {
	if mmUpdatePersonByID.defaultExpectation != nil {
		mmUpdatePersonByID.mock.t.Fatalf("Default expectation is already set for the personRepository.UpdatePersonByID method")
	}

	if len(mmUpdatePersonByID.expectations) > 0 {
		mmUpdatePersonByID.mock.t.Fatalf("Some expectations are already set for the personRepository.UpdatePersonByID method")
	}

	mmUpdatePersonByID.mock.funcUpdatePersonByID = f
	mmUpdatePersonByID.mock.funcUpdatePersonByIDOrigin = minimock.CallerInfo(1)
	return mmUpdatePersonByID.mock
}

// When sets expectation for the personRepository.UpdatePersonByID which will trigger the result defined by the following
// Then helper
func (mmUpdatePersonByID *mPersonRepositoryMockUpdatePersonByID) When(id int32, person models.Person) *PersonRepositoryMockUpdatePersonByIDExpectation {
	if mmUpdatePersonByID.mock.funcUpdatePersonByID != nil {
		mmUpdatePersonByID.mock.t.Fatalf("PersonRepositoryMock.UpdatePersonByID mock is already set by Set")
	}

	expectation := &PersonRepositoryMockUpdatePersonByIDExpectation{
		mock:               mmUpdatePersonByID.mock,
		params:             &PersonRepositoryMockUpdatePersonByIDParams{id, person},
		expectationOrigins: PersonRepositoryMockUpdatePersonByIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdatePersonByID.expectations = append(mmUpdatePersonByID.expectations, expectation)
	return expectation
}

// Then sets up personRepository.UpdatePersonByID return parameters for the expectation previously defined by the When method
func (e *PersonRepositoryMockUpdatePersonByIDExpectation) Then(err error) *PersonRepositoryMock {
	e.results = &PersonRepositoryMockUpdatePersonByIDResults{err}
	return e.mock
}

// Times sets number of times personRepository.UpdatePersonByID should be invoked
func (mmUpdatePersonByID *mPersonRepositoryMockUpdatePersonByID) Times(n uint64) *mPersonRepositoryMockUpdatePersonByID {
	if n == 0 {
		mmUpdatePersonByID.mock.t.Fatalf("Times of PersonRepositoryMock.UpdatePersonByID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdatePersonByID.expectedInvocations, n)
	mmUpdatePersonByID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdatePersonByID
}

func (mmUpdatePersonByID *mPersonRepositoryMockUpdatePersonByID) invocationsDone() bool {
	if len(mmUpdatePersonByID.expectations) == 0 && mmUpdatePersonByID.defaultExpectation == nil && mmUpdatePersonByID.mock.funcUpdatePersonByID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdatePersonByID.mock.afterUpdatePersonByIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdatePersonByID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdatePersonByID implements personRepository
func (mmUpdatePersonByID *PersonRepositoryMock) UpdatePersonByID(id int32, person models.Person) (err error) {
	mm_atomic.AddUint64(&mmUpdatePersonByID.beforeUpdatePersonByIDCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdatePersonByID.afterUpdatePersonByIDCounter, 1)

	mmUpdatePersonByID.t.Helper()

	if mmUpdatePersonByID.inspectFuncUpdatePersonByID != nil {
		mmUpdatePersonByID.inspectFuncUpdatePersonByID(id, person)
	}

	mm_params := PersonRepositoryMockUpdatePersonByIDParams{id, person}

	// Record call args
	mmUpdatePersonByID.UpdatePersonByIDMock.mutex.Lock()
	mmUpdatePersonByID.UpdatePersonByIDMock.callArgs = append(mmUpdatePersonByID.UpdatePersonByIDMock.callArgs, &mm_params)
	mmUpdatePersonByID.UpdatePersonByIDMock.mutex.Unlock()

	for _, e := range mmUpdatePersonByID.UpdatePersonByIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdatePersonByID.UpdatePersonByIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdatePersonByID.UpdatePersonByIDMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdatePersonByID.UpdatePersonByIDMock.defaultExpectation.params
		mm_want_ptrs := mmUpdatePersonByID.UpdatePersonByIDMock.defaultExpectation.paramPtrs

		mm_got := PersonRepositoryMockUpdatePersonByIDParams{id, person}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmUpdatePersonByID.t.Errorf("PersonRepositoryMock.UpdatePersonByID got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdatePersonByID.UpdatePersonByIDMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

			if mm_want_ptrs.person != nil && !minimock.Equal(*mm_want_ptrs.person, mm_got.person) {
				mmUpdatePersonByID.t.Errorf("PersonRepositoryMock.UpdatePersonByID got unexpected parameter person, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdatePersonByID.UpdatePersonByIDMock.defaultExpectation.expectationOrigins.originPerson, *mm_want_ptrs.person, mm_got.person, minimock.Diff(*mm_want_ptrs.person, mm_got.person))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdatePersonByID.t.Errorf("PersonRepositoryMock.UpdatePersonByID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdatePersonByID.UpdatePersonByIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdatePersonByID.UpdatePersonByIDMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdatePersonByID.t.Fatal("No results are set for the PersonRepositoryMock.UpdatePersonByID")
		}
		return (*mm_results).err
	}
	if mmUpdatePersonByID.funcUpdatePersonByID != nil {
		return mmUpdatePersonByID.funcUpdatePersonByID(id, person)
	}
	mmUpdatePersonByID.t.Fatalf("Unexpected call to PersonRepositoryMock.UpdatePersonByID. %v %v", id, person)
	return
}

// UpdatePersonByIDAfterCounter returns a count of finished PersonRepositoryMock.UpdatePersonByID invocations
func (mmUpdatePersonByID *PersonRepositoryMock) UpdatePersonByIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdatePersonByID.afterUpdatePersonByIDCounter)
}

// UpdatePersonByIDBeforeCounter returns a count of PersonRepositoryMock.UpdatePersonByID invocations
func (mmUpdatePersonByID *PersonRepositoryMock) UpdatePersonByIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdatePersonByID.beforeUpdatePersonByIDCounter)
}

// Calls returns a list of arguments used in each call to PersonRepositoryMock.UpdatePersonByID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdatePersonByID *mPersonRepositoryMockUpdatePersonByID) Calls() []*PersonRepositoryMockUpdatePersonByIDParams {
	mmUpdatePersonByID.mutex.RLock()

	argCopy := make([]*PersonRepositoryMockUpdatePersonByIDParams, len(mmUpdatePersonByID.callArgs))
	copy(argCopy, mmUpdatePersonByID.callArgs)

	mmUpdatePersonByID.mutex.RUnlock()

	return argCopy
}

// MinimockUpdatePersonByIDDone returns true if the count of the UpdatePersonByID invocations corresponds
// the number of defined expectations
func (m *PersonRepositoryMock) MinimockUpdatePersonByIDDone() bool {
	if m.UpdatePersonByIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdatePersonByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdatePersonByIDMock.invocationsDone()
}

// MinimockUpdatePersonByIDInspect logs each unmet expectation
func (m *PersonRepositoryMock) MinimockUpdatePersonByIDInspect() {
	for _, e := range m.UpdatePersonByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PersonRepositoryMock.UpdatePersonByID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdatePersonByIDCounter := mm_atomic.LoadUint64(&m.afterUpdatePersonByIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdatePersonByIDMock.defaultExpectation != nil && afterUpdatePersonByIDCounter < 1 {
		if m.UpdatePersonByIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PersonRepositoryMock.UpdatePersonByID at\n%s", m.UpdatePersonByIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PersonRepositoryMock.UpdatePersonByID at\n%s with params: %#v", m.UpdatePersonByIDMock.defaultExpectation.expectationOrigins.origin, *m.UpdatePersonByIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdatePersonByID != nil && afterUpdatePersonByIDCounter < 1 {
		m.t.Errorf("Expected call to PersonRepositoryMock.UpdatePersonByID at\n%s", m.funcUpdatePersonByIDOrigin)
	}

	if !m.UpdatePersonByIDMock.invocationsDone() && afterUpdatePersonByIDCounter > 0 {
		m.t.Errorf("Expected %d calls to PersonRepositoryMock.UpdatePersonByID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdatePersonByIDMock.expectedInvocations), m.UpdatePersonByIDMock.expectedInvocationsOrigin, afterUpdatePersonByIDCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *PersonRepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCreatePersonInspect()

			m.MinimockDeletePersonByIDInspect()

			m.MinimockGetAllPersonInspect()

			m.MinimockGetPersonByIDInspect()

			m.MinimockUpdatePersonByIDInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *PersonRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *PersonRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreatePersonDone() &&
		m.MinimockDeletePersonByIDDone() &&
		m.MinimockGetAllPersonDone() &&
		m.MinimockGetPersonByIDDone() &&
		m.MinimockUpdatePersonByIDDone()
}
